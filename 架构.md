# TravelInAndroid.
# 二。架构知识：2021-08-01～2021-08-31. 
## 07-26 手写动态换肤框架
    ### 手写动态换肤框架及高可扩展性换肤应用回放
        1.registerActivityLifecycleCallbacks执行在Activity.setContentView之前
        2.registerActivityLifecycleCallbacks执行在Activity.onCreate之后
        3.涉及到android.view.LayoutInflater.Factory2的功能：
            1。小红书的平行动画
                思路就是设置Factory2，重写onCreateView拿到对应的attr，然后再通过属性动画改变期动画效果
            2。防止重复点击
                思路就是通过设置Factory，然后替换view的创建，并重写onClick的执行逻辑com.rookie.travelinandroid.super_structure.click.FilterClickListener
            3。动态换肤通用做法
            4。动态换肤扩展性的做法
                1.内置皮肤资源
                    主要思路就是在BaseActivity设置LayoutInflater.Factory，告诉系统使用我们自己的factory.createView方法，然后自定义
                    CustomAppCompatViewInflater继承自AppCompatViewInflater，通过拦截对应的tag，完成对指定view的换肤
                2。加载apk中的皮肤包资源
                    主要思路就是将apk中的资源，通过反射调用addAssetPath方法后，加入到Resource中，以便app可以访问到对应的资源文件
        4。mfactorySet置为false

## 热门开源库源码分析
### 1.网络
#### 1.1 Retrofit
#### 1.2 OKHttp
    07-30 OkHttp源码解读
### 2.数据库
    GreenDao
### 3.图片
#### 3.1 Glide
#### 3.2 Picasso
#### 3.3 Fresco
### 4.依赖注入
#### 4.1 ButterKnife-->07-29
    ButterKnife是依赖注入框架，帮助我们实现findViewById/setOnClickListener等常规操作
    1。implementation 'com.jakewharton:butterknife:10.2.3'
       annotationProcessor 'com.jakewharton:butterknife-compiler:10.2.3'
    当前版本的原理是：APT+反射
    其中，APT=Annotation Processor Tool 专门用来处理注解，该注解作用域编译期，并将有注解的类，生成XXX_ViewBinding.class并跟随代码打包到apk中
    反射作用在运行阶段，ButterKnife.bind(this)时,会拿当前类的Class并拼接上_ViewBinding，然后使用ClassLoader将第一步中随代码打包进入apk的XXX_ViewBinding.class加载进来，
    并拿到该Class的构造方法，然后通过constructor.newInstance(target, source);方法调用到XXX_ViewBinding.class的构造方法，并在构造方法中将目标Activity/Fragment/CustomView等类中
    有注解的View或者OnClick设置点击事件
    问题：
    1。注解如何处理，会扫描所有的类吗？是运行时注解or编译时注解？
    TODO 源码解读：
    2。注解新生成的模板类如何与当前Activity/Fragment/CustomView中对应的view对应起来
    A:注解生成XXX_ViewBinding.class时，其构造方法会传入当前类对象，这样就拿到了当前类的对象，然后再对其成员变量赋值or完成方法调用
    @UiThread
      public EventBusMainActivity_ViewBinding(final EventBusMainActivity target, View source) {
      //当前activity的对象
        this.target = target;

        View view;
        view = Utils.findRequiredView(source, R.id.test_post, "field 'testPostTv' and method 'testPost'");
        //赋值
        target.testPostTv = Utils.castView(view, R.id.test_post, "field 'testPostTv'", TextView.class);
        view7f0900eb = view;
        //设置点击事件
        view.setOnClickListener(new DebouncingOnClickListener() {
          @Override
          public void doClick(View p0) {
            target.testPost();
          }
        });
      }
#### 4.2 Dagger2
### 5.事件总线
    EventBus-->07-29
    EventBus是观察者模式，基于发布-订阅的，大小只有60K，EventBus可以理解为Observable与Observer之间的纽带
    1.implementation 'org.greenrobot:eventbus:3.2.0'
    2.implementation 'org.greenrobot:eventbus:2.4.0'
    问题：
        1。事件-观察者->方法回调是如何完成的？
        2。线程的切换是如何完成的
        3。不同版本之间有什么区别
    解答：
        Q：事件-观察者->方法回调是如何完成的？
        A：1。Events are posted ({@link #post(Object)}) to the bus, which delivers it to subscribers that have a matching handler
           method for the event type.
           从注释上看，EventBus通过post方法，将事件（Event）post到bus，然后，这个事件就会被deliver到对应的观察者，
           前提，该观察者可以处理该类型的事件，也就是被Subscribe注解的方法的参数和上面的Event相同的类型
           2。而被Subscribe注解的方法也有要求：must be public, return nothing (void),* and have exactly one parameter (the event)
           源码：
           EventBus.getDefault().register(this);//注册观察者
           1。首先是getDefault的 单例
           2。register方法概括下来就是：找到当前类中所有：1。public 2。参数长度为1 3。被Subscribe注解的方法，然后以当前类class为key，满足条件的List<SubscribeMethod>为value存储在MethodCache中，方便后续使用
           3。细节
            1。register-注册
            public void register(Object subscriber) {
                    Class<?> subscriberClass = subscriber.getClass();//当前类的class
                    //3。1找到所有符合条件的注解方法，最终调用了findUsingReflectionInSingleClass方法
                    List<SubscriberMethod> subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);
                    synchronized (this) {
                        for (SubscriberMethod subscriberMethod : subscriberMethods) {
                        //3。2 订阅
                            subscribe(subscriber, subscriberMethod);
                        }
                    }
                }
            private void findUsingReflectionInSingleClass(FindState findState) {
                    Method[] methods;
                    try {
                        // This is faster than getMethods, especially when subscribers are fat classes like Activities
                        //3。1。1拿到所有方法
                        methods = findState.clazz.getDeclaredMethods();
                    } catch (Throwable th) {
                      。。。
                    }
                    for (Method method : methods) {
                        int modifiers = method.getModifiers();
                        //3。1。2拿到方法是public/protected/private。。。必须是public的
                        if ((modifiers & Modifier.PUBLIC) != 0 && (modifiers & MODIFIERS_IGNORE) == 0) {
                            Class<?>[] parameterTypes = method.getParameterTypes();
                            //3。1。3方法参数必须是1个
                            if (parameterTypes.length == 1) {
                                Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);
                                //3。1。4有Subscribe注解
                                if (subscribeAnnotation != null) {
                                    Class<?> eventType = parameterTypes[0];
                                    if (findState.checkAdd(method, eventType)) {
                                        ThreadMode threadMode = subscribeAnnotation.threadMode();
                                        //3。1。5构建SubscriberMethod对象，里面有Method,threadMode,priority,sticky
                                        findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode,
                                                subscribeAnnotation.priority(), subscribeAnnotation.sticky()));
                                    }
                                }
                            } else if (strictMethodVerification && method.isAnnotationPresent(Subscribe.class)) {
                              ...
                            }
                        } else if (strictMethodVerification && method.isAnnotationPresent(Subscribe.class)) {
                           ...
                        }
                    }
                }
                register阶段关键的数据结构是：
                                private static final Map<Class<?>, List<SubscriberMethod>> METHOD_CACHE = new ConcurrentHashMap<>();
                                它是以Class为key，Class中所有符合条件的注解的方法的List为value保存起来，以达到缓存的目的
            2。subscribe-订阅
                org.greenrobot.eventbus.EventBus.subscribe
                    private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
                        //2。1拿到当前订阅方法（被Subscribe注解的方法）的参数类型（如：java.lang.String.class），也就是说，当前方法只对这种参数类型感兴趣
                        Class<?> eventType = subscriberMethod.eventType;
                        Subscription newSubscription = new Subscription(subscriber, subscriberMethod);
                        CopyOnWriteArrayList<Subscription> subscriptions = subscriptionsByEventType.get(eventType);
                         //2。2以参数类型为key,对应的方法的List为value存储
                         subscriptionsByEventType.put(eventType, subscriptions);
                         。。。

                        int size = subscriptions.size();
                        for (int i = 0; i <= size; i++) {
                            //检查priority，根据priority来决定插入的位置
                           。。。
                        }
                        //2。3拿到当前订阅者（XXXActivity.class）
                        List<Class<?>> subscribedEvents = typesBySubscriber.get(subscriber);
                         。。。
                        //2。4将当前订阅者与感兴趣的参数类型的List关联起来
                        subscribedEvents.add(eventType);

                        if (subscriberMethod.sticky) {
                        //处理粘性事件
                           。。。
                        }
                    }
                subscribe阶段关键的数据结构是：
                    1。
                    //key为参数类型的Class，value为所有的对此参数类型感兴趣的观察者Subscription(Subscriber,SubscriberMethod)，如String.class->List<AXXActivity.class,BXXActivity.class>
                    private final Map<Class<?>, CopyOnWriteArrayList<Subscription>> subscriptionsByEventType;
                    可以通过这个结构找到所有对该事件类型感兴趣的Subscription->Subscriber->SubscriberMethod->method然后调用

                    2。
                    //key为具体的订阅者（如AActivity.class）,value是当前订阅者内的所有感兴趣的类型，如AXXActivity.class->List<String.class,Integer.class>
                    private final Map<Object, List<Class<?>>> typesBySubscriber;
                    可以通过这个类判断当前类是否被注册过
                    public synchronized boolean isRegistered(Object subscriber) {
                            return typesBySubscriber.containsKey(subscriber);
                    }


                    3。
                    //key为当前的事件类型，也就是订阅方法中的参数类型，value就是当前的事件对象
                    private final Map<Class<?>, Object> stickyEvents;
            3。post-发送普通事件
                3。1概括：
                  调用链：
                       org.greenrobot.eventbus.EventBus.post->postSingleEvent->postSingleEventForEventType->postToSubscription
                       ->invokeSubscriber/mainThreadPoster/backgroundPoster/asyncPoster
                3。2源码
                  关键代码：
                    private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class<?> eventClass) {
                          CopyOnWriteArrayList<Subscription> subscriptions;
                          synchronized (this) {
                          //通过方法类型找到对应的所有的观察者，然后回调其订阅方法
                              subscriptions = subscriptionsByEventType.get(eventClass);
                          }
                          if (subscriptions != null && !subscriptions.isEmpty()) {
                              for (Subscription subscription : subscriptions) {
                                  postingState.event = event;
                                  postingState.subscription = subscription;
                                  boolean aborted;
                                  try {
                                      postToSubscription(subscription, event, postingState.isMainThread);
                                      aborted = postingState.canceled;
                                  } finally {
                                      postingState.event = null;
                                      postingState.subscription = null;
                                      postingState.canceled = false;
                                  }
                                  if (aborted) {
                                      break;
                                  }
                              }
                              return true;
                          }
                          return false;
                      }
            4。postStickyEvent:发送黏性事件
                关键代码：
                 public void postSticky(Object event) {
                        synchronized (stickyEvents) {
                        //将事件假如到黏性事件的队列里面去，由于stickyEvents是一个map，所以多次发送同一个sticky event，只会保留最后一个
                            stickyEvents.put(event.getClass(), event);
                        }
                        // Should be posted after it is putted, in case the subscriber wants to remove immediately
                        post(event);
                 }
                 解释：EventBus是单例的，所以，在发送黏性事件时，EventBus先将事件加入到stickyEvents的map集合中去，然后，再下一个界面调用register然后subscribe时，
                      如果当前subscribeMethod是sticky的，会马上遍历stickyEvents拿到stickyEvent的eventType与subscribeMethod感兴趣的eventType对比，若一致，那么
                      直接调用checkPostStickyEventToSubscription(newSubscription, stickyEvent)方法，完成黏性事件的发送及对应方法的调用
            5。注解：
                 javaCompileOptions {
                        annotationProcessorOptions {
                            arguments = [ eventBusIndex : 'com.rookie.travelinandroid.MyEventBusIndex' ]
                        }
                 }
                 dependencies{
                     implementation 'org.greenrobot:eventbus:3.2.0'
                     annotationProcessor 'org.greenrobot:eventbus-annotation-processor:3.0.1'
                 }


### 6.响应式编程
     RXJava
### 7.内存泄漏
     LeakCanary
## 基础知识
### 注解->07-30



