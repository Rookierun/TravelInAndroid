# TravelInAndroid.
# 二。架构知识：2021-08-01～2021-08-31. 
## 07-26 手写动态换肤框架
    ### 手写动态换肤框架及高可扩展性换肤应用回放
        1.registerActivityLifecycleCallbacks执行在Activity.setContentView之前
        2.registerActivityLifecycleCallbacks执行在Activity.onCreate之后
        3.涉及到android.view.LayoutInflater.Factory2的功能：
            1。小红书的平行动画
                思路就是设置Factory2，重写onCreateView拿到对应的attr，然后再通过属性动画改变期动画效果
            2。防止重复点击
                思路就是通过设置Factory，然后替换view的创建，并重写onClick的执行逻辑com.rookie.travelinandroid.super_structure.click.FilterClickListener
            3。动态换肤通用做法
            4。动态换肤扩展性的做法
                1.内置皮肤资源
                    主要思路就是在BaseActivity设置LayoutInflater.Factory，告诉系统使用我们自己的factory.createView方法，然后自定义
                    CustomAppCompatViewInflater继承自AppCompatViewInflater，通过拦截对应的tag，完成对指定view的换肤
                2。加载apk中的皮肤包资源
                    主要思路就是将apk中的资源，通过反射调用addAssetPath方法后，加入到Resource中，以便app可以访问到对应的资源文件
        4。mfactorySet置为false

## 热门开源库源码分析
### 1.网络
#### 1.1 Retrofit
#### 1.2 OKHttp
    07-30 OkHttp源码解读
    1。使用
        1。1依赖
        implementation("com.squareup.okhttp3:okhttp:4.9.1")
        implementation("com.squareup.okhttp3:logging-interceptor:4.9.1")
        1。2请求
            同步
            android.os.NetworkOnMainThreadException
            java.net.UnknownHostException: Unable to resolve host "wwww.baidu.com": No address associated with hostname
                域名解析的问题
            java.net.UnknownHostException: Unable to resolve host "www.baidu.com": No address associated with hostname
            java.net.UnknownHostException: Unable to resolve host "www.baidu.com": No address associated with hostname
                模拟器没网。。。

            添加header：
                private final OkHttpClient client = new OkHttpClient();
                public void run() throws Exception {
                    Request request = new Request.Builder()
                        .url("https://api.github.com/repos/square/okhttp/issues")
                        .header("User-Agent", "OkHttp Headers.java")
                        .addHeader("Accept", "application/json; q=0.5")
                        .addHeader("Accept", "application/vnd.github.v3+json")
                        .build();

                    try (Response response = client.newCall(request).execute()) {
                      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);

                      System.out.println("Server: " + response.header("Server"));
                      System.out.println("Date: " + response.header("Date"));
                      System.out.println("Vary: " + response.headers("Vary"));
                    }
                }
            1。Get
                 public void testGet(View view) {
                        Runnable runnable = () -> {
                            Request syncRequest = new Request.Builder().url("https://www.baidu.com/").build();
                            Call call = client.newCall(syncRequest);
                            try {
                                Response response = call.execute();
                                String string = response.body().string();
                                Log.e("test", "response:" + string);
                            } catch (IOException e) {
                                e.printStackTrace();
                            }
                        };
                    }
            2。Post
                1。表单
                    MediaType mediaTypeMarkDown = MediaType.parse("text/x-markdown; charset=utf-8");
                    FormBody formBody = new FormBody.Builder().add("username", "test1")
                            .add("password", "pwd")
                            .add("repassword", "pwd").build();
                    Request request = new Request.Builder().url("https://www.wanandroid.com/user/register").post(formBody).build();
                    Call call = client.newCall(request);
                    try {
                        Response response = call.execute();
                        String string = response.body().string();
                        Log.e("test", "response of post:" + string);
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                2。图片/文件
                 public static final MediaType MEDIA_TYPE_MARKDOWN
                      = MediaType.parse("text/x-markdown; charset=utf-8");

                  private final OkHttpClient client = new OkHttpClient();

                  public void run() throws Exception {
                    File file = new File("README.md");

                    Request request = new Request.Builder()
                        .url("https://api.github.com/markdown/raw")
                        .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, file))
                        .build();

                    try (Response response = client.newCall(request).execute()) {
                      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);

                      System.out.println(response.body().string());
                    }
                  }
            3。上传&下载
                1。下载
                     String imgUrl = "https://pics6.baidu.com/feed/bf096b63f6246b60d41f7a6e90e8e244510fa2b5.jpeg?token=44c43662f4dccd9a81cdeb740f4f898a";
                     Request downLoadRequest = new Request.Builder().url(imgUrl).build();
                     Call call = client.newCall(downLoadRequest);
                     call.enqueue(new Callback() {
                         @Override
                         public void onFailure(Call call, IOException e) {

                         }

                         @Override
                         public void onResponse(Call call, Response response) throws IOException {
                             ResponseBody body = response.body();
                             if (body != null && body.contentLength() > 0) {
                                 InputStream inputStream = body.byteStream();
                                 Bitmap bitmap = BitmapFactory.decodeStream(inputStream);
                                 OKHttpActivity.this.runOnUiThread(new Runnable() {
                                     @Override
                                     public void run() {
                                         imageView.setImageBitmap(bitmap);
                                     }
                                 });
                             }

                         }
                     });
                2。上传文件
                public static final MediaType MEDIA_TYPE_MARKDOWN
                      = MediaType.parse("text/x-markdown; charset=utf-8");

                  private final OkHttpClient client = new OkHttpClient();

                  public void run() throws Exception {
                    File file = new File("README.md");

                    Request request = new Request.Builder()
                        .url("https://api.github.com/markdown/raw")
                        .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, file))
                        .build();

                    try (Response response = client.newCall(request).execute()) {
                      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);

                      System.out.println(response.body().string());
                    }
                  }
                3。多文件上传
                private static final String IMGUR_CLIENT_ID = "...";
                private static final MediaType MEDIA_TYPE_PNG = MediaType.parse("image/png");
                RequestBody requestBody = new MultipartBody.Builder()
                        .setType(MultipartBody.FORM)
                        .addFormDataPart("title", "Square Logo")
                        .addFormDataPart("image", "logo-square.png",
                            RequestBody.create(MEDIA_TYPE_PNG, new File("website/static/logo-square.png")))
                        .build();

                Request request = new Request.Builder()
                        .header("Authorization", "Client-ID " + IMGUR_CLIENT_ID)
                        .url("https://api.imgur.com/3/image")
                        .post(requestBody)
                        .build();

                try (Response response = client.newCall(request).execute()) {
                  if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);

                  System.out.println(response.body().string());
                }
    2。问题：
        2。1 OKIO&IO&NIO
        2。2关于http的header
        2。3用的什么通信，连接是怎么建立的
        2。4一些常用的状态码
           100~199：指示信息，表示请求已接收，继续处理
           200~299：请求成功，表示请求已被成功接收、理解
           300~399：重定向，要完成请求必须进行更进一步的操作
           400~499：客户端错误，请求有语法错误或请求无法实现
           500~599：服务器端错误，服务器未能实现合法的请求
    3。官方文档翻译：
        The HTTP client’s job is to accept your request and produce its response.
        This is simple in theory but it gets tricky in practice.
            http client用来接收请求并产生响应信息，而这理论上简单，实际操作却比较棘手
        Requests¶
        Each HTTP request contains a URL, a method (like GET or POST), and a list of headers.
        Requests may also contain a body: a data stream of a specific content type.
            每个http请求都包含一个url，一个请求方法（get/post/delete。。。）还有一系列的header，当然
            请求也有可能包含一个请求体：一种指定内容的形式的数据流
        Responses¶
        The response answers the request with a code (like 200 for success or 404 for not found), headers, and its own optional body.
            响应，回复请求时带有一个响应码（200，成功，404 不存在），一系列的响应header，以及它自身可选的响应体
        Rewriting Requests
        When you provide OkHttp with an HTTP request, you’re describing the request at a high-level: “fetch me this URL with these headers.”
        For correctness and efficiency, OkHttp rewrites your request before transmitting it.
        重写请求
            当你提供给okhttp一个http请求是，你是在一个较高的级别在描述这个请求："给我带着这些header拿这个url的数据"，为了正确和高效，Okhttp会在发送合格请求前重写它
        OkHttp may add headers that are absent from the original request, including Content-Length, Transfer-Encoding, User-Agent, Host, Connection, and Content-Type.
        It will add an Accept-Encoding header for transparent response compression unless the header is already present. If you’ve got cookies, OkHttp will add a Cookie header with them.
            OkHttp可能会给你的请求添加一些原来并不存在的header，包括Content-Length，Transfer-Encoding，User-Agent，Host，Connection，以及Content-Type
            如果request中不存在Accept-Encoding 这个header，OkHttp也会增加一个用来压缩响应信息，如果你已经有Cookie了，OkHttp也会在header中增加一个Cookie
        Some requests will have a cached response. When this cached response isn’t fresh, OkHttp can do a conditional GET to download an updated response if it’s newer than what’s cached.
        This requires headers like If-Modified-Since and If-None-Match to be added.
            有些请求的响应已经被缓存了，如果这些缓存信息已经过期了，如果新的响应信息较缓存更新的画，OkHttp会做一个Get请求来拿到更新了的响应信息并且缓存起来
            这一操作需要在请求中增加If-Modified-Since and If-None-Match这两个header
        Rewriting Responses¶
        If transparent compression was used, OkHttp will drop the corresponding response headers Content-Encoding and Content-Length because they don’t apply to the decompressed response body.
        If a conditional GET was successful, responses from the network and cache are merged as directed by the spec.
        重写响应
            如果使用了透明压缩，OkHttp会丢掉响应中相关的Content-Encoding and Content-Length header，因为这些header并没有应用到解压响应体中
            如果一个条件性的Get请求成功了，网络响应以及缓存会直接在当前维度被合并
        Follow-up Requests¶
        When your requested URL has moved, the webserver will return a response code like 302 to indicate the document’s new URL.
        OkHttp will follow the redirect to retrieve a final response.
        后续请求
            当你请求的url已经移动了，web服务器会返回一个code为302的response来告诉你新的url，而OkHttp也会继续重定向到这个地址以便抓去最终的响应信息
        If the response issues an authorization challenge, OkHttp will ask the Authenticator (if one is configured) to satisfy the challenge.
        If the authenticator supplies a credential, the request is retried with that credential included.
            如果响应遇到了认证的挑战， OKHttp会获取Authenticator信息（如果设置了）来应对这个挑战，如果authenticator提供了一个可以用的信息，那么请求就会带着这个authenticator继续执行
        Retrying Requests¶
        Sometimes connections fail: either a pooled connection was stale and disconnected, or the webserver itself couldn’t be reached.
        OkHttp will retry the request with a different route if one is available.
        请求重试
        有些时候链接会失败，或许是因为链接池的链接过期了，或者是断开了，再或者是服务器不可达了，OKHttp会在其他线路可用的情况下再重试其他线路来执行这个请求
        Calls
        With rewrites, redirects, follow-ups and retries, your simple request may yield many requests and responses.
        OkHttp uses Call to model the task of satisfying your request through however many intermediate requests and responses are necessary.
        Typically this isn’t many! But it’s comforting to know that your code will continue to work if your URLs are redirected or if you failover to an alternate IP address.
        Calls
            再经过rewrites, redirects, follow-ups and retries之后，你的一个简单的请求可能会产生大量的请求和响应
            OKHttp使用Call来将你的任务模型化以便在不管有多少立即的请求以及多少必要的响应的条件下，满足你的请求
            典型的就是这个并不多，但是当知道你的url被重定向了或者你又选用了一个被选的ip地址后，你的代码依然继续工作时，这是很令人欣慰的
        Calls are executed in one of two ways:
        Synchronous: your thread blocks until the response is readable.
        Asynchronous: you enqueue the request on any thread, and get called back on another thread when the response is readable.
            Call会被以以下两种方式之一执行：
                1。同步，你的线程在响应可用之前一直是阻塞的
                2。异步，你在任意一个线程enqueue你的request，然后当你的响应在另一个线程可用时，它会给你一个callback
        Calls can be canceled from any thread. This will fail the call if it hasn’t yet completed!
        Code that is writing the request body or reading the response body will suffer an IOException when its call is canceled.
            Calls可以在任意一个线程取消，如果这个call还没完成，那么，此次call就会被cancel
            如果call被cancel了，写入request body中的代码或读取response body的代码会发生一个IOException的异常
        Dispatch
        For synchronous calls, you bring your own thread and are responsible for managing how many simultaneous requests you make.
        Too many simultaneous connections wastes resources; too few harms latency.
        调度
            对于同步的调用，你持有你的当前线程而且对于有多少了同步请求的创建也是有管理责任的，太多同时的链接会浪费资源，太少又会影响延迟
        For asynchronous calls, Dispatcher implements policy for maximum simultaneous requests.
        You can set maximums per-webserver (default is 5), and overall (default is 64).
            对于异步请求，Dispatcher对于同时请求的最大数量做了策略，你可以对每一个服务器设置最大数（默认是5个），以及全局的最大请求数（默认是64个）
        Caching¶
        OkHttp implements an optional, off by default, Cache.
        OkHttp aims for RFC correct and pragmatic caching behaviour, following common real-world browser like Firefox/Chrome and server behaviour when ambiguous.
        缓存
            OKHttp提供了一个可选的默认关闭的缓存策略
            OKHttp锚定RFC链接和务实的缓存行为，当模棱两可时，会跟随现实世界的如Firefox/Chrome的缓存策略
        Connections¶
        Although you provide only the URL, OkHttp plans its connection to your webserver using three types: URL, Address, and Route.
        链接
            尽管你只提供了Url，OkHttp却用了3个类型的数据组成了它自己的connection：URL，Address，Route
        URLs¶
        URLs (like https://github.com/square/okhttp) are fundamental to HTTP and the Internet.
        In addition to being a universal, decentralized naming scheme for everything on the web, they also specify how to access web resources.
        URLS
            URL是HTTP和Internet的基础
            另外，作为一个全站，去中心化的域名，他们也指明了如果访问web资源
        URLs are abstract:
            They specify that the call may be plaintext (http) or encrypted (https), but not which cryptographic algorithms should be used.
            Nor do they specify how to verify the peer’s certificates (the HostnameVerifier) or which certificates can be trusted (the SSLSocketFactory).

            They don’t specify whether a specific proxy server should be used or how to authenticate with that proxy server.
            URL是抽象的
            URL指明了Call是使用Http还是Https，但是并没指定使用那个加密算法。URL既没指明怎么校验服务器证书也没指明哪些证书可以被信任
            URL不指明应该使用那个代理服务器，也不指明怎么验证那个代理服务器
        They’re also concrete: each URL identifies a specific path (like /square/okhttp) and query (like ?q=sharks&lang=en). Each webserver hosts many URLs.
            他们同样是具体的，每个url指向了一个具体的路径以及对应的query信息，每个服务器的主机都有多个URL
        Addresses¶
        Addresses specify a webserver (like github.com) and all of the static configuration necessary to connect to that server: the port number, HTTPS settings, and preferred network protocols (like HTTP/2 or SPDY).
        地址
            Address指明了一个具体的服务器（github.com）以及链接这台服务器所需的静态配置，比如：the port number, HTTPS settings, and preferred network protocols (like HTTP/2 or SPDY).
        URLs that share the same address may also share the same underlying TCP socket connection. Sharing a connection has substantial performance benefits: lower latency, higher throughput (due to TCP slow start) and conserved battery.
        OkHttp uses a ConnectionPool that automatically reuses HTTP/1.x connections and multiplexes HTTP/2 and SPDY connections.
            共享同一个address的URL同样共享底层的TCP socket链接，共享一个链接有很多性能好处：低延迟，高吞吐，以及电量友好
            OKHTTP用了一个ConnectionPool来自动的重用HTTP/1.x链接和多路的HTTp/2和Spdy链接
        In OkHttp some fields of the address come from the URL (scheme, hostname, port) and the rest come from the OkHttpClient.
            在OKHttp中，address的一些字段来源于URL，（Scheme，hostname，port）其他的来源于OKHTTPClient
        Routes¶
        Routes supply the dynamic information necessary to actually connect to a webserver.
        This is the specific IP address to attempt (as discovered by a DNS query), the exact proxy server to use (if a ProxySelector is in use), and which version of TLS to negotiate (for HTTPS connections).

        There may be many routes for a single address.
        For example, a webserver that is hosted in multiple datacenters may yield multiple IP addresses in its DNS response.
        路由
            路由提供了连接到服务器的必须的动态信息，这个是具体的ip地址（dns解析），试探使用一个具体的代理服务器的，以及使用哪个版本的TLS来加密

            对于一个单一的address有多个路由
            比如：一个web服务器在dns响应里面可能产生多个IP地址
        Connections¶
        When you request a URL with OkHttp, here’s what it does:

            It uses the URL and configured OkHttpClient to create an address. This address specifies how we’ll connect to the webserver.
            It attempts to retrieve a connection with that address from the connection pool.
            If it doesn’t find a connection in the pool, it selects a route to attempt. This usually means making a DNS request to get the server’s IP addresses. It then selects a TLS version and proxy server if necessary.
            If it’s a new route, it connects by building either a direct socket connection, a TLS tunnel (for HTTPS over an HTTP proxy), or a direct TLS connection. It does TLS handshakes as necessary.
            It sends the HTTP request and reads the response.
        链接
            当你用OKHttp请求一个地址是，下面就是okhttp所做的事情
            1。它使用url和配置了的OKHttpClient来创建一个address，这个address指明了我们怎么连接到web服务器
            2。它尝试在链接池中拿到这个地址的链接
            3。如果池中没有当前地址的链接，它就选择一个路由尝试。这也通常意味着做一个dns的请求来拿到服务器的ip地址，然后如果有有必要的画，再选择一个TLS的version以及代理服务器
            4。如果是一个新的路由，它通过建立一个直接的socket链接/一个tls通道（对HTTPS）或者一个直接的TLS链接。然后有必要的话，做TLS握手
            5。发送http request，读取response
        If there’s a problem with the connection, OkHttp will select another route and try again. This allows OkHttp to recover when a subset of a server’s addresses are unreachable.
        It’s also useful when a pooled connection is stale or if the attempted TLS version is unsupported.
            如果这个链接有问题，OKHttp会选择另一个路由然后重试， 这允许OkHttp在一个服务器地址不可达的时候自己恢复请求，当一个链接池不可用或者尝试的TLS版本不被支持的时候也很有用
        Once the response has been received, the connection will be returned to the pool so it can be reused for a future request. Connections are evicted from the pool after a period of inactivity.
            一旦拿到了响应，链接必须马上回到池子里面，以便它可以被后面的请求重用，如果一个链接在一段时间内都不活跃，那么这个链接会被踢出链接池
    4。总结：
        OKHttp使用了责任链模式，将一个请求分成了多个步骤并交给不同的责任人去处理
        1。概览
            同步->new OkHttpClient().newCall(request).execute()
            异步->new OkHttpClient().newCall(request).enqueue(CallBack)
            OKHttpClient就成为了开发者与OKHttp之间的桥梁，开发者通过OKHttpClient配置请求所需的header，url，body等一系列参数，然后OkHttpClient再将这些参数传递给OKHttp
        2。所设计到的关键类
            2.1总体流程：
                OkHttpClient:
                    Dispatcher:线程调度
                Request:
                    HttpMethod
                    HttpUrl
                    Headers
                    RequestBody
                Call->RealCall
                    Transmitter->ExchangeFinder->RealConnectionPool
                Response
            2.2细节
                1。不管是同步请求还是异步请求，最终都会走到okhttp3.RealCall.getResponseWithInterceptorChain方法，不同点就是
                    1.同步请求执行的是RealCall，异步请求执行的是AsyncCall
                    2。异步执行，是Dispatcher将AsyncCall加入到readyAsyncCalls队列中，而同步请求是加入到runnignCalls队列中，执行完毕后从队列中移除
                2。责任链模式的体现：getResponseWithInterceptorChain方法
                     interceptors.add(new RetryAndFollowUpInterceptor(client));
                     interceptors.add(new BridgeInterceptor(client.cookieJar()));
                     interceptors.add(new CacheInterceptor(client.internalCache()));
                     interceptors.add(new ConnectInterceptor(client));
                     interceptors.add(new CallServerInterceptor(forWebSocket));
                     1.RetryAndFollowUpInterceptor:
                        负责请求准备，比如用url，address，route组成Transmitter进而组成
                     2.BridgeInterceptor
                        负责请求前Request的封装，比如添加必要的header，指定压缩类型，指定请求链接的是http/https
                        负责请求后的Response的解压缩
                     3.CacheInterceptor
                        负责请求的缓存处理
                     4.ConnectInterceptor
                        负责建立链接，并缓存可用链接
                        关键类：
                            Transmitter：Bridge between OkHttp's application and network layers.
                            ExchangeFinder：Attempts to find the connections for a sequence of exchanges
                                Address：A specification for a connection to an origin server.
                                RealConnectionPool：
                                    RealConnection：
                                RouteSelector：Selects routes to connect to an origin server.
                                    Route：The concrete route used by a connection to reach an abstract origin server.
                                    Selection
                        判断当前的连接是否可以使用：流是否已经被关闭，并且已经被限制创建新的流；
                        如果当前的连接无法使用，就从连接池中获取一个连接；
                        连接池中也没有发现可用的连接，创建一个新的连接，并进行握手，然后将其放到连接池中。
                     5.CallServerInterceptor
                        负责真正与服务器进行交互，使用Okio进行io的处理

### 2.数据库
    GreenDao
### 3.图片
#### 3.1 Glide
#### 3.2 Picasso
#### 3.3 Fresco
### 4.依赖注入
#### 4.1 ButterKnife-->07-29
    ButterKnife是依赖注入框架，帮助我们实现findViewById/setOnClickListener等常规操作
    1。implementation 'com.jakewharton:butterknife:10.2.3'
       annotationProcessor 'com.jakewharton:butterknife-compiler:10.2.3'
    当前版本的原理是：APT+反射
    其中，APT=Annotation Processor Tool 专门用来处理注解，该注解作用域编译期，并将有注解的类，生成XXX_ViewBinding.class并跟随代码打包到apk中
    反射作用在运行阶段，ButterKnife.bind(this)时,会拿当前类的Class并拼接上_ViewBinding，然后使用ClassLoader将第一步中随代码打包进入apk的XXX_ViewBinding.class加载进来，
    并拿到该Class的构造方法，然后通过constructor.newInstance(target, source);方法调用到XXX_ViewBinding.class的构造方法，并在构造方法中将目标Activity/Fragment/CustomView等类中
    有注解的View或者OnClick设置点击事件
    问题：
    1。注解如何处理，会扫描所有的类吗？是运行时注解or编译时注解？
    A：运行时注解
    @Retention(RUNTIME) @Target(FIELD)
    public @interface BindView {
      /** View ID to which the field will be bound. */
      @IdRes int value();
    }

    /butterknife-compiler/src/main/java/butterknife/compiler/ButterKnifeProcessor.java

      private Set<Class<? extends Annotation>> getSupportedAnnotations() {
      //支持的注解类型
        Set<Class<? extends Annotation>> annotations = new LinkedHashSet<>();

        annotations.add(BindAnim.class);
        annotations.add(BindArray.class);
        annotations.add(BindBitmap.class);
        annotations.add(BindBool.class);
        annotations.add(BindColor.class);
        annotations.add(BindDimen.class);
        annotations.add(BindDrawable.class);
        annotations.add(BindFloat.class);
        annotations.add(BindFont.class);
        annotations.add(BindInt.class);
        annotations.add(BindString.class);
        annotations.add(BindView.class);
        annotations.add(BindViews.class);
        annotations.addAll(LISTENERS);

        return annotations;
      }
    2。注解新生成的模板类如何与当前Activity/Fragment/CustomView中对应的view对应起来
    A:注解生成XXX_ViewBinding.class时，其构造方法会传入当前类对象，这样就拿到了当前类的对象，然后再对其成员变量赋值or完成方法调用
    @UiThread
      public EventBusMainActivity_ViewBinding(final EventBusMainActivity target, View source) {
      //当前activity的对象
        this.target = target;

        View view;
        view = Utils.findRequiredView(source, R.id.test_post, "field 'testPostTv' and method 'testPost'");
        //赋值
        target.testPostTv = Utils.castView(view, R.id.test_post, "field 'testPostTv'", TextView.class);
        view7f0900eb = view;
        //设置点击事件
        view.setOnClickListener(new DebouncingOnClickListener() {
          @Override
          public void doClick(View p0) {
            target.testPost();
          }
        });
      }
#### 4.2 Dagger2
### 5.事件总线
    EventBus-->07-29
    EventBus是观察者模式，基于发布-订阅的，大小只有60K，EventBus可以理解为Observable与Observer之间的纽带
    1.implementation 'org.greenrobot:eventbus:3.2.0'
    2.implementation 'org.greenrobot:eventbus:2.4.0'
    3。（有注解用注解，没注解用反射）
    问题：
        1。事件-观察者->方法回调是如何完成的？
        2。线程的切换是如何完成的
        3。不同版本之间有什么区别
    解答：
        Q：事件-观察者->方法回调是如何完成的？
        A：1。Events are posted ({@link #post(Object)}) to the bus, which delivers it to subscribers that have a matching handler
           method for the event type.
           从注释上看，EventBus通过post方法，将事件（Event）post到bus，然后，这个事件就会被deliver到对应的观察者，
           前提，该观察者可以处理该类型的事件，也就是被Subscribe注解的方法的参数和上面的Event相同的类型
           2。而被Subscribe注解的方法也有要求：must be public, return nothing (void),* and have exactly one parameter (the event)
           源码：
           EventBus.getDefault().register(this);//注册观察者
           1。首先是getDefault的 单例
           2。register方法概括下来就是：找到当前类中所有：1。public 2。参数长度为1 3。被Subscribe注解的方法，然后以当前类class为key，满足条件的List<SubscribeMethod>为value存储在MethodCache中，方便后续使用
           3。细节
            1。register-注册
            public void register(Object subscriber) {
                    Class<?> subscriberClass = subscriber.getClass();//当前类的class
                    //3。1找到所有符合条件的注解方法，最终调用了findUsingReflectionInSingleClass方法
                    List<SubscriberMethod> subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);
                    synchronized (this) {
                        for (SubscriberMethod subscriberMethod : subscriberMethods) {
                        //3。2 订阅
                            subscribe(subscriber, subscriberMethod);
                        }
                    }
                }
            private void findUsingReflectionInSingleClass(FindState findState) {
                    Method[] methods;
                    try {
                        // This is faster than getMethods, especially when subscribers are fat classes like Activities
                        //3。1。1拿到所有方法
                        methods = findState.clazz.getDeclaredMethods();
                    } catch (Throwable th) {
                      。。。
                    }
                    for (Method method : methods) {
                        int modifiers = method.getModifiers();
                        //3。1。2拿到方法是public/protected/private。。。必须是public的
                        if ((modifiers & Modifier.PUBLIC) != 0 && (modifiers & MODIFIERS_IGNORE) == 0) {
                            Class<?>[] parameterTypes = method.getParameterTypes();
                            //3。1。3方法参数必须是1个
                            if (parameterTypes.length == 1) {
                                Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);
                                //3。1。4有Subscribe注解
                                if (subscribeAnnotation != null) {
                                    Class<?> eventType = parameterTypes[0];
                                    if (findState.checkAdd(method, eventType)) {
                                        ThreadMode threadMode = subscribeAnnotation.threadMode();
                                        //3。1。5构建SubscriberMethod对象，里面有Method,threadMode,priority,sticky
                                        findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode,
                                                subscribeAnnotation.priority(), subscribeAnnotation.sticky()));
                                    }
                                }
                            } else if (strictMethodVerification && method.isAnnotationPresent(Subscribe.class)) {
                              ...
                            }
                        } else if (strictMethodVerification && method.isAnnotationPresent(Subscribe.class)) {
                           ...
                        }
                    }
                }
                register阶段关键的数据结构是：
                                private static final Map<Class<?>, List<SubscriberMethod>> METHOD_CACHE = new ConcurrentHashMap<>();
                                它是以Class为key，Class中所有符合条件的注解的方法的List为value保存起来，以达到缓存的目的
            2。subscribe-订阅
                org.greenrobot.eventbus.EventBus.subscribe
                    private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
                        //2。1拿到当前订阅方法（被Subscribe注解的方法）的参数类型（如：java.lang.String.class），也就是说，当前方法只对这种参数类型感兴趣
                        Class<?> eventType = subscriberMethod.eventType;
                        Subscription newSubscription = new Subscription(subscriber, subscriberMethod);
                        CopyOnWriteArrayList<Subscription> subscriptions = subscriptionsByEventType.get(eventType);
                         //2。2以参数类型为key,对应的方法的List为value存储
                         subscriptionsByEventType.put(eventType, subscriptions);
                         。。。

                        int size = subscriptions.size();
                        for (int i = 0; i <= size; i++) {
                            //检查priority，根据priority来决定插入的位置
                           。。。
                        }
                        //2。3拿到当前订阅者（XXXActivity.class）
                        List<Class<?>> subscribedEvents = typesBySubscriber.get(subscriber);
                         。。。
                        //2。4将当前订阅者与感兴趣的参数类型的List关联起来
                        subscribedEvents.add(eventType);

                        if (subscriberMethod.sticky) {
                        //处理粘性事件
                           。。。
                        }
                    }
                subscribe阶段关键的数据结构是：
                    1。
                    //key为参数类型的Class，value为所有的对此参数类型感兴趣的观察者Subscription(Subscriber,SubscriberMethod)，如String.class->List<AXXActivity.class,BXXActivity.class>
                    private final Map<Class<?>, CopyOnWriteArrayList<Subscription>> subscriptionsByEventType;
                    可以通过这个结构找到所有对该事件类型感兴趣的Subscription->Subscriber->SubscriberMethod->method然后调用

                    2。
                    //key为具体的订阅者（如AActivity.class）,value是当前订阅者内的所有感兴趣的类型，如AXXActivity.class->List<String.class,Integer.class>
                    private final Map<Object, List<Class<?>>> typesBySubscriber;
                    可以通过这个类判断当前类是否被注册过
                    public synchronized boolean isRegistered(Object subscriber) {
                            return typesBySubscriber.containsKey(subscriber);
                    }


                    3。
                    //key为当前的事件类型，也就是订阅方法中的参数类型，value就是当前的事件对象
                    private final Map<Class<?>, Object> stickyEvents;
            3。post-发送普通事件
                3。1概括：
                  调用链：
                       org.greenrobot.eventbus.EventBus.post->postSingleEvent->postSingleEventForEventType->postToSubscription
                       ->invokeSubscriber/mainThreadPoster/backgroundPoster/asyncPoster
                3。2源码
                  关键代码：
                    private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class<?> eventClass) {
                          CopyOnWriteArrayList<Subscription> subscriptions;
                          synchronized (this) {
                          //通过方法类型找到对应的所有的观察者，然后回调其订阅方法
                              subscriptions = subscriptionsByEventType.get(eventClass);
                          }
                          if (subscriptions != null && !subscriptions.isEmpty()) {
                              for (Subscription subscription : subscriptions) {
                                  postingState.event = event;
                                  postingState.subscription = subscription;
                                  boolean aborted;
                                  try {
                                      postToSubscription(subscription, event, postingState.isMainThread);
                                      aborted = postingState.canceled;
                                  } finally {
                                      postingState.event = null;
                                      postingState.subscription = null;
                                      postingState.canceled = false;
                                  }
                                  if (aborted) {
                                      break;
                                  }
                              }
                              return true;
                          }
                          return false;
                      }
            4。postStickyEvent:发送黏性事件
                关键代码：
                 public void postSticky(Object event) {
                        synchronized (stickyEvents) {
                        //将事件假如到黏性事件的队列里面去，由于stickyEvents是一个map，所以多次发送同一个sticky event，只会保留最后一个
                            stickyEvents.put(event.getClass(), event);
                        }
                        // Should be posted after it is putted, in case the subscriber wants to remove immediately
                        post(event);
                 }
                 解释：EventBus是单例的，所以，在发送黏性事件时，EventBus先将事件加入到stickyEvents的map集合中去，然后，再下一个界面调用register然后subscribe时，
                      如果当前subscribeMethod是sticky的，会马上遍历stickyEvents拿到stickyEvent的eventType与subscribeMethod感兴趣的eventType对比，若一致，那么
                      直接调用checkPostStickyEventToSubscription(newSubscription, stickyEvent)方法，完成黏性事件的发送及对应方法的调用
            5。注解：
                 javaCompileOptions {
                        annotationProcessorOptions {
                            arguments = [ eventBusIndex : 'com.rookie.travelinandroid.MyEventBusIndex' ]
                        }
                 }
                 dependencies{
                     implementation 'org.greenrobot:eventbus:3.2.0'
                     annotationProcessor 'org.greenrobot:eventbus-annotation-processor:3.0.1'
                 }

                 /** This class is generated by EventBus, do not edit. */
                 public class MyEventBusIndex implements SubscriberInfoIndex {
                     private static final Map<Class<?>, SubscriberInfo> SUBSCRIBER_INDEX;

                     static {
                         SUBSCRIBER_INDEX = new HashMap<Class<?>, SubscriberInfo>();

                         putIndex(new SimpleSubscriberInfo(com.rookie.travelinandroid.super_structure.event_bus.EventBusMainActivity.class,
                                 true, new SubscriberMethodInfo[] {
                             new SubscriberMethodInfo("update", String.class, ThreadMode.MAIN, 10, true),
                         }));

                     }

                     private static void putIndex(SubscriberInfo info) {
                         SUBSCRIBER_INDEX.put(info.getSubscriberClass(), info);
                     }

                     @Override
                     public SubscriberInfo getSubscriberInfo(Class<?> subscriberClass) {
                         SubscriberInfo info = SUBSCRIBER_INDEX.get(subscriberClass);
                         if (info != null) {
                             return info;
                         } else {
                             return null;
                         }
                     }
                 }

                编译时生成MyEventBusIndex，避免运行时大量的反射

### 6.响应式编程
     RXJava
### 7.内存泄漏
     LeakCanary
## 基础知识
### APT 注解->07-30
#### 1。什么是APT
     APT:Annotation Processing Tool ,可以用来在编译时扫描和处理注解，通过APT可以获取到注解和被注解对象的相关信息，拿到注解信息后，可以根据我们的需要
     自动生成一些代码，而且，注解处理发生在编译阶段，而IOC-反射发生在程序运行时，所以相比反射来说，大大提高了程序的性能，APT核心时AbstractProcessor
#### 2。哪些框架用了注解
     EventBus,ButterKnife,ARouter,Retrofit,Dagger2都用了APT的技术
#### 3。自定义注解
    3.1:遇到的问题：
    Q：自定义的processor编译期不执行
    A：1.compiler-module的gradle:
        annotationProcessor 'com.google.auto.service:auto-service:1.0-rc3'
        implementation 'com.google.auto.service:auto-service:1.0-rc3'
       2.getSupportedAnnotationTypes()需要返回要处理的注解类型
    Q:className都是啥样的？
    A:
        simpleName:TestShape
        qualifiedName:com.rookie.travelinandroid.super_structure.annotation.TestShape
    Q:Attempt to access Class object for TypeMirror com.rookie.travelinandroid.super_structure.annotation.TestShape
    A:
        reason:MirroredTypeException:
            The annotation returned by this method could contain an element whose value is of type Class. This value cannot be returned directly: information necessary to locate and load a class (such as the class loader to use) is not available, and the class might not be loadable at all. Attempting to read a Class object by invoking the relevant method on the returned annotation will result in a MirroredTypeException, from which the corresponding TypeMirror may be extracted.
            Similarly, attempting to read a Class[]-valued element will result in a MirroredTypesException.
        解决：
            try {
                        //该类已经被编译
                        Class clazz = annotation.type();
                    } catch (MirroredTypeException e) {
                        //该类未被编译
                        messager.printMessage(Diagnostic.Kind.NOTE, e.getMessage());
                        TypeMirror typeMirror = e.getTypeMirror();
                        DeclaredType declaredType = (DeclaredType) typeMirror;
                        TypeElement typeElement = (TypeElement) declaredType.asElement();
                        String canonicalName = typeElement.getQualifiedName().toString();
                        String simpleName = typeElement.getSimpleName().toString();
                        messager.printMessage(Diagnostic.Kind.NOTE, "exception:"+canonicalName);
                    }


