# TravelInAndroid. 

# 三。性能优化：2021-09-01～2021-09-30.
## 09-03 内存性能优化
### 1.JVM内存模型
    1.线程私有区
        程序计数器：记录程序执行位置
        虚拟机栈：局部变量，方法的返回i地址等
            OOM StackOverflow会发生在这里
            不会产生内存碎片
        本地方法栈
    2.共享数据区
        堆：对象&数组
            OOM
            GC的主要区域
        方法区：
            常量池：
                静态变量，类，接口，方法名等
### GC
    1.内存回收策略
        1.引用计数算法，循环引用不回收
        2.可达性分析算法：
            关键是GCRoot，当前对象是否可以达到GCRoot
        Java回收算法：
            1.标记-清除算法
                对每个对象进行标记，效率不高
                会产生内存碎片
            2.复制算法：将内存划分为大小相等的两块，一块内存用完后把用完的那块中存活的都copy到另一块中，然后清除当前内存区域 
                浪费一半空间
            3.标记-整理算法：标记，然后把存活对象往一端进行移动，清理其余内存
                1.避免标记-清除导致的内存碎片
                2.避免了复制算法的浪费空间
            4.分代收集：新生代存活率低，复制算法清除，老年代对象存活率搞使用标记整理-算法            
        Android内存管理机制
            1.内存弹性分配，分配值与最大值受设备限制
            2.OOM场景：内存真正不足，可用内存不足
        Dalvik与Art区别
            1.Dalvik仅固定一种回收算法
            2.Art回收算法可运行期选择
            3.Art具备内存整理能力
        Low Memory Killer
            进程分类：前台，可见，服务，后台，空进程
            回收收益：
    2.四种引用：
        强引用：内存不足也不会回收
        软引用：内存不足时，回收
        弱引用：第一次GC时标记，第二次GC时回收
        虚引用：回收时，拿到通知，得不到具体对象的引用
    3.工具
        1.AS-Memory Profiler
        2。platform-tools->hprof conv.exe->hprof -z infile ouputfile->xxx.hprof-->Eclipse Memory Analyzer(MAT)
            -z:排除zygote的heap信息
    4.处理方案
        1.对于源码or第三方代码：采用反射，切开引用链
        2.良好的编码习惯：
          1.数据类型，不要使用比需求占空间的 类型
          2.循环尽量使用foreach，避免自动拆装箱
          3.字符串的连接尽量少用加号(+
          4.注意：.重复申请内存的问题：
            同一个方法多次调用，如递归函数 ，回调函数中new对象,读流直接在循环中new对象等
            不要在onMeause()  onLayout() onDraw()  中去刷新UI（requestLayout）
          5.尽量使用IntentService,而不是Service  