# TravelInAndroid. 

# 三。性能优化：2021-09-01～2021-09-30.
## 09-03 内存性能优化
### 1.JVM内存模型
    1.线程私有区
        程序计数器：记录程序执行位置
        虚拟机栈：局部变量，方法的返回i地址等
            OOM StackOverflow会发生在这里
            不会产生内存碎片
        本地方法栈
    2.共享数据区
        堆：对象&数组
            OOM
            GC的主要区域
        方法区：
            常量池：
                静态变量，类，接口，方法名等
### GC
    1.内存回收策略
        1.引用计数算法，循环引用不回收
        2.可达性分析算法：
            关键是GCRoot，当前对象是否可以达到GCRoot
        Java回收算法：
            1.标记-清除算法
                对每个对象进行标记，效率不高
                会产生内存碎片
            2.复制算法：将内存划分为大小相等的两块，一块内存用完后把用完的那块中存活的都copy到另一块中，然后清除当前内存区域 
                浪费一半空间
            3.标记-整理算法：标记，然后把存活对象往一端进行移动，清理其余内存
                1.避免标记-清除导致的内存碎片
                2.避免了复制算法的浪费空间
            4.分代收集：新生代存活率低，复制算法清除，老年代对象存活率搞使用标记整理-算法            
        Android内存管理机制
            1.内存弹性分配，分配值与最大值受设备限制
            2.OOM场景：内存真正不足，可用内存不足
        Dalvik与Art区别
            1.Dalvik仅固定一种回收算法
            2.Art回收算法可运行期选择
            3.Art具备内存整理能力
        Low Memory Killer
            进程分类：前台，可见，服务，后台，空进程
            回收收益：
    2.四种引用：
        强引用：内存不足也不会回收
        软引用：内存不足时，回收
        弱引用：第一次GC时标记，第二次GC时回收
        虚引用：回收时，拿到通知，得不到具体对象的引用
    3.工具
        1.AS-Memory Profiler
        2。platform-tools->hprof conv.exe->hprof -z infile ouputfile->xxx.hprof-->Eclipse Memory Analyzer(MAT)
            -z:排除zygote的heap信息
    4.处理方案
        1.对于源码or第三方代码：采用反射，切开引用链
        2.良好的编码习惯：
          1.数据类型，不要使用比需求占空间的 类型
          2.循环尽量使用foreach，避免自动拆装箱
          3.字符串的连接尽量少用加号(+
          4.注意：.重复申请内存的问题：
            同一个方法多次调用，如递归函数 ，回调函数中new对象,读流直接在循环中new对象等
            不要在onMeasure()  onLayout() onDraw()  中去刷新UI（requestLayout）
          5.尽量使用IntentService,而不是Service
### Java虚拟机
    1。结构
        1。方法区：被所有线程共享的运行时内存区域，用来存储已经被Java虚拟机加载的累的结构信息，包括运行时的常量池，字段和方法信息，静态变量等数据。
            方法区是Java啊堆的逻辑组成部分，方法区并不等同于永久代，只是因为HotSpot VM用永久代来实现方法区。
        2。Java虚拟机栈：每一条Java虚拟机线程都有一个线程私有的Java虚拟机栈，它的生命周期与线程相同。
            一个虚拟机栈包含了多个栈帧，一个栈帧用类存储局部变量表，操作数栈，动态链接方法出口等信息。
            Java虚拟机规范中定义了2中异常情况：
                1。如果线程请求分配的栈容量超过Java虚拟机所允许的最大容量，Java虚拟机会抛出StackOverFlowError
                2。如果Java虚拟机可以动态扩展，但是扩展时无法申请到足够的内存，或者创建新的线程时，没有足够的内存去创建对应的Java虚拟机栈，则会抛出OutOfMemoryError异常
        3。程序计数器：也叫PC寄存器是一块较小的内存空间，用来确定下一条要执行的指令的地址
            在虚拟机模型中，字节码计时器工作时，就是通过改变程序计数器来选取下一条需要执行的字节码指令的。
            为了在县城切换后能恢复到正确的执行位置，每个线程都会有一个独立的程序计数器，所以程序计数器是线程私有的
            程序计数器是规范中唯一没有规定任何OutOfMemoryError情况的数据区域
        4。堆：被所有线程共享的运行时内存区域，用来存放对象实例，这些对象被垃圾收集器管理
            会抛出OutOfMemoryError异常
        5。本地方法栈：和Java虚拟机栈对应，记录native方法的执行，是线程私有的。
        6。运行时常量池：Runtime Constant Pool,并不是运行时数据区域的其中一份子，而是方法区的一部分，由于Class文件不仅包含类的版本，接口，字段和方法等信息，还包含常量池，
            它用来存放编译时期生成的字面量和符号引用，这些内容会在类加载后存放起方法区的运行时常量池中。运行时常量池可以理解为是类或接口的常量池的运行时表现形式
            会抛出OutOfMemoryError异常。
    2。Class文件的结构及生命周期
        1.文件结构
            ClassFile {
                u4 magic;  // 魔法数字，表明当前文件是.class文件，固定0xCAFEBABE
                u2 minor_version; // 分别为Class文件的副版本和主版本
                u2 major_version;
                u2 constant_pool_count; // 常量池计数
                cp_info constant_pool[constant_pool_count-1];  // 常量池内容
                u2 access_flags; // 类访问标识
                u2 this_class; // 当前类
                u2 super_class; // 父类
                u2 interfaces_count; // 实现的接口数
                u2 interfaces[interfaces_count]; // 实现接口信息
                u2 fields_count; // 字段数量
                field_info fields[fields_count]; // 包含的字段信息
                u2 methods_count; // 方法数量
                method_info methods[methods_count]; // 包含的方法信息
                u2 attributes_count;  // 属性数量
                attribute_info attributes[attributes_count]; // 各种属性
            }
        2。类的生命周期
            一个Java文件被加载到Java虚拟机内存中到从内存中卸载的过程被称为类的生命周期。可分为：
            1。加载：查找并加载Class文件
            2。链接
                验证：确保被导入类型的正确性
                准备：为累的静态字段分配字段，并用默认值初始化这些字段
                解析：虚拟机将常量池内的富豪引用替换为直接引用
            3。初始化：根据《深入理解Java虚拟机》的描述，加载阶段（不是类的加载）主要做了3件事情：
                1。根据特定名称查找类或接口类型的二进制字节流，这件事有Java虚拟机外部的ClassLoader完成
                2。将这个二进制字节流所代表的静态存储结构转化为方法去的运行时数据结构
                3。在内存中生成一个代表这类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。
            4。使用
            5。卸载
        3。ClassLoader
            1。Bootstrap ClassLoader：引导类加载器，用于加载JDK指定的核心类库，如java.lang，java.util.这些系统类，加载的目录是：
                1。$JAVA_HOME/jre/lib目录
                2。-Xbootclasspath参数指定的目录
            2。Extensions ClassLoader：扩展类加载器，用于加载Java扩展类，加载一下目录中的类库：
                1。加载$JAVA_HOME/jre/lib/ext目录
                2。系统属性java.ext.dir所指定的目录
            3。Application ClassLoader（应用程序类加载器），又称为System ClassLoader主要加载：
                1。当前应用程序ClassPath目录
                2。系统属性java.class.path指定的目录

    3。对象
        1。对象的创建
            1。判断对象对应的类是否加载，链接，和初始化。
                虚拟机接收到一条new指令时，首先会检查这个指定的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被类加载器加载，链接和初始化过
            2。为对象分配内存
                类加载完成后，接着会在Java对中划分一块内存给对象
            3。处理并发安全问题，两种方式：
                1。对分配内存空间的动作进行同步处理，比如在虚拟机采用CAS算法并配上失败充实的方式保证更新操作的原子性
                2。每个线程在Java对中预先分配一小块内存，这块内存称为Thread Local Allocation Buffer TLAB，线程需要分配内存时，就在对应的TLAB上分配内存，
                当线程中的TLAB用完并且被分配到新的TLAB时，这时候才需要同步锁定
            4。初始化分配到的内存空间
            5。设置对象的对象头
            6。执行init方法进行初始化
                执行init方法，初始化对象的成员变量，调用类的构造方法，这样一个对象就被创建出来了。
        2。对象的存储
            1。对象的内存布局：
                1。对象头
                    Mark World：HashCode，所状态标志，GC分代年龄，线程池有的锁等等
                    元数据指针：用于指向方法区中目标类的元数据，通过元数据可以去定对象的具体类型
                2。实例数据：
                    用于存储对象中各种类型的字段信息
                3。对齐填充：
                    不一定存在，占位符的作用，没有特别的含义
    4。内存的分配和回收
        1。Java中的引用
            1。强引用：不回收，即使OutOfMemoryError
            2。软引用：不足时尝试回收，如果依然没有足够的内存，抛出OutOfMemoryError，Java中是SoftReference
            3。弱引用：GC时回收，但不是马上回收，Java提供了WeakReference实现弱引用。
            4。虚引用：
        2。垃圾的标记算法
            2。1引用计数法：有循环引用的问题
            2。2跟搜索算法
                哪些可以作为GCRoots：
                    1。Java栈引用的对象
                    2。本地方法栈用JNI引用的对象
                    3。方法区中运行时常量池引用的对象
                    4。方法区中，静态属性引用的对象
                    5。运行中的线程
                    6。由BootStrapLoader加载的对象
                    7。GC控制的对象
        3。对象的生命周期：
            1。创建阶段：Created 具体步骤为：
                1。为对象分配存储空间
                2。构造对象
                3。从超类到子类对static成员进行初始化
                4。递归调用超类的构造方法
                5。调用子类的构造方法
            2。应用阶段：In Use
                当对象被创建，并分配给变量赋值时，状态就切换到了应用阶段。这一阶段的对象至少具有4种引用中的一个。
            3。不可见阶段：Invisible
                在程序中找不到对象的任何强引用，在不可见阶段，对象仍可能被特殊的强引用GC Roots持有着，比如对象被本地方法栈中的JNI引用或者被运行中的线程引用等
            4。不可达阶段：Unrechable：
                在程序中找不到对象的任何强引用，并且垃圾收集器发现对象不可达
            5。收集阶段：Collected
                垃圾收集器已经法相对象不可达，并且GC已经准备好要对该对象的内存空间重新进行分配，这时，如果该对象重写了finalize方法，则会调用该方法
            6。终结阶段：Finalized
                该对象执行完finalize方法后仍然处于不可达状态时，或者对象没有重写finalize方法，则该对象进入终结阶段，并等待GC回收该对象空间
            7。对象空间重新分配阶段：Deallocated
                当GC对对象的内存空间进行回收或者在分配时，这个对象就彻底消失了

           所以：对象被标记为不可达状态时不会马上被GC回收，因为被标记为不可达状态的对象进入收集阶段，这时会执行该对象重写的finalize方法，
           如果没有重写或者重写后没重新与一个可达的对象进行关联才会进入终结阶段，并最终被回收

        3。垃圾收集算法
            3。1标记-清除
                1。产生碎片，则导致可用的连续内存不足以分配给较大的对象， 进而引发新的GC收集动作
                2。如果存活对象较少，效率高些
            3。2复制算法
                1。浪费内存
            3。3标记-压缩
                1。将存活的对象压缩到内粗你的一端，然后对边界意外的内存进行回收，回收后，已用和未用的内存都各自一边
                被广泛用于老年的中
            3。4分代收集
                1。分代年龄分类：
                    1。新生代：Eden
                        又分为：From Survivor和To Survivor
                    2。老年代
                1。根据Java对的空间划分，垃圾手机的类型分为2中：
                    1。Minor Collection：新生代垃圾收集
                    2。Full Collection：对老年代进行收集
                2。执行一次Minor Collection后，Eden空间存活的对象会被复制到To Survivor空间，并切经过之前一次Minor Collection并在From Survivor空间存活的仍年轻的对象会复制到Survivor空间
                   当所有的存活对象被复制到To Survivor空间后，也就意味着Eden空间和From Survivor都是可回收的对象了，然后GC执行Minor Collection Eden空间和From Survivor空间都会被清空，
                   新生代存活的对象都放在To Survivor中了，然后From和To交换位置，这就是复制算法在新生代中的应用。
