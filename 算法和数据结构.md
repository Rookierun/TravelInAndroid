# TravelInAndroid. 
# 七。算法&数据结构：2021-01-16～2021-01-31.
## 01.数据结构&算法总览-->07-29
#### 一维数据结构
    基础：数组array，链表linked-list
    高级：栈stack，队列queue，双端队列deque，集合list/set，映射map，
#### 二维数据结构
    基础：树tree，图graph
    高级：二叉搜索树 binary-search-tree（red-black tree，AVL），堆heap，并查集 disjoint set 字典树 Trie
#### 特殊数据结构
    位运算，布隆过滤器，LRU
#### 算法
    if-else ,switch->branch
    for,while-loop->Iteration
    递归Recursion（Divide&Conquer，Backtrace）
    搜索Search：深度优先Depth first Search，广度优先Breadth first search
    动态规划 Dynamic Programming
    二分查找Binary Search
    贪心算法Greedy
    数学Math，几何Geometry
    注意：在头脑中会议上面几种算法的思想和代码模版
### 算法题，做一遍远远不够
### 切题四件套
    明题意，
    列出所有的解决方案，比较时间/空间复杂度，优化
    编码
    测试
### 五遍刷题法
####    第一遍
    1。五分钟明白题意，找思路，
    2。直接看解法or直接Coding，注意比较解法的优劣
####    第二遍
    1。自己写->LeetCode提交
    2。多种解法比较，体会-优化
####    第三遍
    1。过了一天后，重新写一遍
####    第四遍
    1。过了一周过后，重新写一遍
####    第五遍
    1。面试前一周的恢复性训练
## 02.时间复杂度与空间复杂度-->07-29
### 时间复杂度 Big O notation
    O(1):常数复杂度
    O(Log n):对数复杂度
        for (int i = 0; i < n; i=i*2) {

        }
    O(n):线性复杂度
        for (int i = 0; i < n; i++) {

        }
    O(n^2):平方复杂度
        for (int i = 0; i < n; i++) {
             for (int j = 0; j < n; j++) {

             }
         }
    O(n^3):立方复杂度
    O(2^n):指数复杂度
    /**
         * 斐波那契数列
         * @param n
         * @return
    */
         int fib(int n) {
                if (n <= 2) {
                    return n;
                }
                return fib(n - 1) + fib(n - 2);
         }
    O(n!):阶乘
### 递归的时间复杂度分析-创建递归状态树
## 03.数组、链表、跳表-->07-30
    1.跳表：Skip List，补足链表的缺陷（访问元素的时间复杂度为O(n)）
    给链表加速的中心思想：升维，空间换时间，添加多级(log 2 n)索引
## 随记
    HashSet底层使用HashMap，无序，唯一
    LinkedHashSet底层使用LinkedHashMap，保证迭代顺序与插入顺序一致
## 04.树，二叉树，二叉搜索树
### 二叉树
    1。只有2个子节点
    树和图的区别：看有没有环
    链表是特殊化的树，树是特殊化的图
    2。二叉树遍历
    前序：根左右
    中序：左根右
    后序：左右根
    3。二叉搜索树
    特征：
        1。空树
        2。左子树小于根节点
        3。右子树都大于根节点
        4。以此类推：左。右子树也分别为二叉查找树（重复性）
        5。中序遍历是升序排列
    时间复杂度：O(log n)
    常见操作；
### 排序
    1。比较类排序：
        交换排序：冒泡排序&快速排序
            冒泡排序：n^2
            快速排序：nLogn 分治思想
        插入排序：简单插入排序&希尔排序
            简单插入排序：
            希尔排序
        选择排序：简单选择排序&堆排序
            简单选择排序：
            堆排序：nLogn
        归并排序：二路归并排序&多路归并排序
            二路归并排序：nLogn 分治思想
            多路归并排序：
    2。简单的排序，时间复杂度n^2
        1。选择排序:
            每次找到最小值，然后放到带排序数组的起始位置
            1。假设第一个元素是最小值
            2。外层循环，将最小值的索引记录为当前循环的位置
            3。内层循环，比较当前元素与最小值的大小，如果arr[j]>arr[minIndex],则交换二者的值
        2。插入排序：
            从前向后逐步构建有序序列；对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入
            1.默认第一个元素已经排好序
            2。记录当前比较的排序好的下一个元素索引，preIndex，然后拿到当前元素current，
            3。如果current比arr[preIndex]小，那么就需要将current移动到下一位置
        3。冒泡排序
            嵌套循环，每次查看相邻的元素，如果逆序就交换
            1。外层循环
            2。内层循环判断当前元素与下一个元素的大小，如果arr[j]>arr[j+1],则二者交换





